= Rapid Prototyping of Graphics Shaders in Modern C++
:revealjs_theme: black
:revealjs_transition: fade
:revealjs_controls: true
:revealjs_progress: true
:revealjs_slideNumber: true
:revealjs_history: true
:revealjs_overview: true
:revealjs_fragments: true
:customcss: main.css
:title-slide-background-image: img/title.png
:source-highlighter: highlightjs
:icons: font

[background-image="img/sd-brand/banner.jpg"]
== Valentin Galea
https://twitter.com/valentin_galea[@valentin_galea]

More than 10 years in
_mobile_, _indie_ and _AAA_ games

image::img/sd-brand/SD-logo-white.svg[SD, 128, 128]

== Agenda
TODO:

== Shaders
[quote]
A computer program that is used to do *shading*
// originally from https://www.clicktorelease.com/talks/scotlandjs-2015/

[%notitle, background-image="img/intro/shaded_shapes.jpg"]
== Shaders Definition
// from https://www.clicktorelease.com/talks/scotlandjs-2015/files/CubeSphereConeCylinderNoBackgrnd.jpg
// alternative: https://qph.ec.quoracdn.net/main-qimg-f441c2d9b120a389f6fa5c995080adaf-c

[quote, Wikipedia]
Depicting depth perception in 3D models or illustrations by varying levels of darkness

[%notitle, background-image="img/intro/pixar_luxo.jpg"]
== Shaders Pixar
// from https://i.ytimg.com/vi/lkKf9DWmR04/maxresdefault.jpg

[quote, Pixar RenderMan 1988]
A computer program that tells the computer how to draw something
//image::https://upload.wikimedia.org/wikipedia/commons/8/84/Phong-shading-sample.jpg[]
// public domain

[state=GPU]
== Shaders on Modern GPU's
image::img/intro/gpu_gtx1080.png[GPU, width="60%", float="right"]

[%left]
`-` Computer graphics

[%left]
`-` Image manipulation

[%left]
`-` Highly parallel computing

== Why on GPU
image::img/intro/cpu_vs_gpu.png[]
// https://steemit.com/gridcoin/@dutch/hardware-and-project-selection-part-1-cpu-vs-gpu

== Types of Shaders
image::img/intro/pipeline.png[pipeline, float="right"]
// https://open.gl/drawing https://creativecommons.org/licenses/by-sa/4.0/

[%left]
Vertex +
Geometry +
Tessellation +
Fragment(Pixel) +
`-----` +
Compute

== Pixel/Fragment Shader
image::img/intro/materials.jpg[mat, width="80%"]

IMPORTANT: We will concentrate on (procedurally generated) image-only shaders

== Motivation
I wanted to create real-time effects like...

[%notitle, background-image="img/motivation/snail.jpg"]
== Example 1

[%notitle, background-image="img/motivation/rainforest.png"]
== Example 2

[%notitle, background-image="img/motivation/temple.png"]
== Example 3

[state=GPU]
== !
on more limited devices...

[cols="a,a"]
|=================
|
image:img/motivation/galaxy-s7-edge.png[s7]
|
image:img/motivation/tablet-pc.png[tablet-pc]
|=================

[state=commute]
== !
image::img/motivation/commute.png[background]
...because of long commutes!

[state=gpu_bug]
== !
image::img/motivation/snail-bug.png[background]

also because GPU driver render bugs

WARNING: taken on desktop PC / Nvidia GTX 1060

== Shading Languages
[state=RSL]
== Pixar RenderMan Language
image::img/intro/renderman.jpg[background]

[source, javascript, role="strech"]
-----
/*
 * red mesh                 red shaded mesh
 */
surface basic() {           surface simple(color Alpha = 1) {
    Ci = (1.0, 0.0, 0.0);       color Clr = (1.0, 0.0, 0.0);
    Oi = 1;                     normal Nn = normalize(N);
}                               Ci = Clr * Alpha * diffuse(Nn);
                                Oi = Alpha;
                            }
-----

== Shading Languages History
For real-time rendering:

- Early: ARB assembly, Cg
- OpenGL shading language (*GLSL*)
- DirectX High-Level Shader Language (*HLSL*)
- PlayStation Shader Language (similar to HLSL)

== A glimpse of GLSL
// from https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/lighting.php
[source, javascript]
-----
varying vec3 N;
varying vec3 v;

void main(void)
{
   vec3 L = normalize(gl_LightSource[0].position.xyz - v);
   vec4 Idiff = gl_FrontLightProduct[0].diffuse 
        * max(dot(N,L), 0.0);
   Idiff = clamp(Idiff, 0.0, 1.0);

   gl_FragColor = Idiff;
}
-----

== A glimpse of HLSL
// from https://www.gamasutra.com/view/feature/131275/implementing_lighting_models_with_.php?page=2
[source, javascript]
-----
float4 main(
    float3 Light: TEXCOORD0,
    float3 Norm : TEXCOORD1) : COLOR
{
    float4 diffuse = { 1.0f, 0.0f, 0.0f, 1.0f };
    float4 ambient = { 0.1, 0.0, 0.0, 1.0 };
    return ambient + diffuse * saturate(dot(Light, Norm));
}
-----

== GLSL vs HLSL
// from https://docs.microsoft.com/en-us/windows/uwp/gaming/glsl-to-hlsl-reference
|==============================================================================
| Procedural, step-centric (C like) | Object oriented, data-centric (C++ like)
| Compilation done in driver        | Client side compilation
| `float`, `int`, `bool`            | `float`, `int`, `bool`, `uint`, `double`
|==============================================================================

== GLSL vs HLSL (continued)
|==============================================================================
| Vector type: `vec2`, `vec3`, `vec4` | Vector type: `float2`, `float3`, `float4`
| Matrix type: `mat2`, `mat3`, `mat4` | Matrix type: `float2x2`, `float3x3`, `float4x4`
2+^| ...textures, samplers, precision modifiers etc
|==============================================================================

== Shading Languages Future
Basically C++ (usually via LLVM)

[.step]
- Metal Shading Language (C++14, Apple)
 * only on iOS devices
- CUDA Heterogeneous Computing (C++11, NVidia)
 * only for computing, not graphics
- HLSL 6.x (C++98'ish, Microsoft)
 * not released yet

== !
Let's see how C++ can help out, NOW!

[state=plan]
== The Plan
[%step]
- image:img/icon/browser.svg[cpp, 64, 64] Pick a shading language and twist C++ to accept it as source code!
- image:img/icon/management.svg[bonus, 64, 64] BONUS: use the preprocessor for transcription back to the original language(s)!

== The Plan (continued)
[%step]
- obligatory preprocessor layer
- vector (linear algebra) types
 * swizzle support
- matrix types
- operators
- "standard library" utility/math functions

== Place Your Bets
We will chose *GLSL* as it's used on _desktop_, _web_ and _mobile_

WARNING: only a subset of it - concentrate on procedural graphics thus minimize/eliminate inputs (textures, vertex data, etc)

== Languages: Declarations
|==============================================================================
| GLSL              | HLSL                  | C++
3+^|
// stupid asciidoctor bug: doesn't respect column centering
{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}
classic basic types
3+^|
{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}{nbsp}
C-style `struct`
| `T name = T ( ... )` | `T name = { ... }` |  both (preproc abstraction)
|==============================================================================

== Languages: Arguments
|===========================================
| GLSL/HLSL     | C++           | Macro glue
| `const in T`  | `const T &`   | `_in(T)`
| `inout T`     | `T &`         | `_inout(T)`
| `out T`       | `T &`         | `_out(T)`
|===========================================

== GLSL ex: Vectors and Matrices
[source, cpp]
-----
// vectors are generic
vec2 texcoord1, texcoord2;
vec3 position;
vec4 myRGBA;
ivec2 textureLookup;
bvec3 less;

// matrices are floating point only
mat2 mat2D;
mat3 optMatrix;
mat4 view, projection;
-----

== Vector Swizzle
Syntactic sugar for easy referring to components (or combination of)

|=========================
| { x, y, z, w } | to represent points or normals
| { r, g, b, a } | to refer to colors (`a` is alpha/translucency)
| { s, t, p, q } | texture coordinates
|=========================

== Vector Swizzle - Examples
.subcomponents mix & match
[source, cpp]
-----
vec4 v4;
v4.rgba;  // is a vec4 and the same as just using v4,
v4.rgb;   // is a vec3,
v4.b;     // is a float,
v4.xy;    // is a vec2,
-----

[source, cpp]
-----
vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);
vec4 swiz= pos.wzyx; // swiz = (4.0, 3.0, 2.0, 1.0)
vec4 dup = pos.xxyy; // dup = (1.0, 1.0, 2.0, 2.0)
-----

.l-value assigment
[source, cpp]
-----
pos.xw = vec2(5.0, 6.0); // pos = (5.0, 2.0, 3.0, 6.0)
pos.xx = vec2(3.0, 4.0); // illegal - 'x' used twice
-----

== Vector Swizzle - Motivation
[source, cpp]
-----
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0, -1.0) * 0.0005;

    return normalize(
        e.xyy * map( pos + e.xyy ).x + 
        e.yyx * map( pos + e.yyx ).x + 
        e.yxy * map( pos + e.yxy ).x + 
        e.xxx * map( pos + e.xxx ).x );
}
-----

== Operators
[cols="a,a"]
|============
| syntax | equivalent
|
[source, cpp]
-----
w = v + u;
-----
|
[source, cpp]
-----
w.x = v.x + u.x;
w.y = v.y + u.y;
w.z = v.z + u.z;
-----
|
[source, cpp]
-----
u = v * m;
-----
|
[source, cpp]
-----
u.x = dot(v, m[0]);
u.y = dot(v, m[1]);
u.z = dot(v, m[2]);
/* dot(a,b) is the inner product of a and b */
-----
|============

[state=STL]
== "Standard Library"
//TODO: table styling attrib are ignored
[cols="%20,%80", width="100%"]
|==========================================================
| Math      | `sin`, `cos`, `radians`, `pow`, `exp`, etc
| Common    | `abs`, `sign`, `floor`, `mod`, `min`, etc
| Utility   | `mix`, `step`, `smoothstep`, etc
| Geometry  | `length`, `dot`, `cross`, `distance`, etc 
2+| Specific texture and image sampling ...
|==========================================================

== !
Recreating all this in C++ ...

== Design of `vector<>`
[source, cpp]
-----
template<typename T, size_t N>
struct vector :
    public vector_base<T, N>
{
    vector();
    vector(scalar_type s);
    template<typename... S> explicit vector(S... args);
...
    scalar_type& operator[](size_t i);
    scalar_type& operator[](size_t i)
...
    vector_type& operator +=(scalar_type s)
    vector_type& operator +=(const vector_type &v);
...
-----

== `static_for` utility
[source, cpp]
-----
template<size_t Begin, size_t End>
struct static_for
{
    template<class Func>
    constexpr void operator ()(Func &&f)
    {
        f(Begin);
        static_for<Begin + 1, End>()(std::forward<Func>(f));
    }
};
-----

[source, cpp]
-----
template<size_t N>
struct static_for<N, N>
{
    template<class Func>
    constexpr void operator ()(Func &&) { /* empty */ }
};
-----

== `vector<>` ctor - basic
[source, cpp]
-----
vector()
{
    static_for<0, N>()([this](size_t i) {
        data[i] = 0;
    });
}

vector(scalar_type s)
{
    static_for<0, N>()([s, this](size_t i) {
        data[i] = s;
    });
}
-----

== `vector<>` ctor - advanced
[source, cpp]
-----
template<typename... S>
explicit vector(S... args)
{
    static_assert((sizeof...(args) <= N), "too many arguments");

    size_t i = 0;
    (construct_at_index(i, std::forward<S>(args)), ...);
}
-----

NOTE: unary fold expression over comma operator: send every arg to specialized processor function

== `vector<>` ctor - advanced (continued)
[source, cpp]
-----
void construct_at_index(size_t &i, scalar_type arg)
{
    data[i++] = arg;
}
-----

[source, cpp]
-----
template<typename Other, size_t Other_N>
void construct_at_index(size_t &i, vector<Other, Other_N> &&arg)
{
    constexpr auto count = std::min(N, Other_N);

    detail::static_for<0, count>()([&](size_t j) {
        data[i++] = arg.data[j];
    });
}
-----

== `vector<>` ctor in action
[source, cpp]
-----
using vec2 = vector<int, 2>;
using vec3 = vector<int, 3>;

vec3 v = vec3(98, vec2(99, 100));
//             ^    ^
//             |    |
//             `-- scalar construct gets called
//                  |
//                  `---- sub-vector construct gets called
//                        and then recursively again
-----

== Godbolt

[source, cpp]
-----
int main()
{
    float a, b;
    scanf("%f %f", &a, &b);

    auto v = vec3(1.f, vec2(a, b));

    printf("%f %f", v.x, v.y);
}
-----

== Godbolt (continued)

[cols="a,a,a"]
|==================
| clang (trunk) | gcc (8.2) | msvc (2017)

| [source, cpp]
-----
call    scanf
movss   xmm0, dword ptr [rsp + 4]
cvtss2sd        xmm1, xmm0
movss   xmm0, dword ptr [rsp]
cvtss2sd        xmm2, xmm0
movsd   xmm0, qword ptr [rip + .LCPI0_0]
mov     edi, offset .L.str.1
mov     al, 3
call    printf
-----

| [source, cpp]
-----
call    scanf
pxor    xmm2, xmm2
pxor    xmm1, xmm1
movsd   xmm0, QWORD PTR .LC1[rip]
mov     edi, OFFSET FLAT:.LC2
mov     eax, 3
cvtss2sd        xmm2, DWORD PTR [rsp+12]
cvtss2sd        xmm1, DWORD PTR [rsp+8]
call    printf
-----

| [source, cpp]
-----
call    scanf
movss   xmm1, DWORD PTR b$[rsp]
lea     rcx, OFFSET FLAT:`string'
movss   xmm0, DWORD PTR a$[rsp]
movss   DWORD PTR $T1[rsp+4], xmm1
movsd   xmm1, QWORD PTR __real@3ff0000000000000
movss   DWORD PTR $T1[rsp], xmm0
movq    rdx, xmm1
mov     rax, QWORD PTR $T1[rsp]
mov     QWORD PTR <args_1>$[rsp], rax
movss   xmm3, DWORD PTR <args_1>$[rsp+4]
movss   xmm2, DWORD PTR <args_1>$[rsp]
cvtps2pd xmm3, xmm3
cvtps2pd xmm2, xmm2
movq    r9, xmm3
movq    r8, xmm2
call    printf
-----

|==================

- clang 5.x and 6.x produce worse code
- gcc's `cvtss2sd` from memory is pessimization (https://stackoverflow.com/a/16597686)

== `vector_base` naive impl
[source, cpp]
-----
template<typename T>
struct vector_base<T, 2>
{
    union
    {
        T data[2];
        struct { T x, y; };
        struct { T s, t; };
        struct { T u, v; };
    }
};
-----

== `vector_base` naive impl (2)
[source, cpp]
-----
template<typename T>
struct vector_base<T, 3>
{
    union
    {
        T data[3];
        struct { T x, y, z; };
        struct { T r, g, b; };
        struct { T s, t, p; };
    }
};
-----

== `vector_base` naive impl (3)
[source, cpp]
-----
template<typename T>
struct vector_base<T, 4>
{
    union
    {
        T data[4];
        struct { T x, y, z, w; };
        struct { T r, g, b, a; };
        struct { T s, t, p, q; };
    }
};
-----

== `vector_base` notes
NOTE: both anonymous `struct` and `union` are permitted, only MSVC complains with warning

WARNING: `union` active member switching can be tricky `[10.5]` but we'll use only trivial types with trivial assignment 

== Swizzle
TIP: We introduce an additional proxy class that allows custom access to the indices and we create all possible permutations (per GLSL/HLSL standard)

[source, cpp]
-----
template<class vector_type, class T, size_t N, size_t... indices>
struct swizzler
{
	T data[N]; // can differ from vector_type
...
};
-----

== Swizzle for `vector<T, 3>`
[source, cpp]
-----
union
{
    T data[3];

    struct {
        swizzler<0>::type x;
        swizzler<1>::type y;
        swizzler<2>::type z;
    };
    struct {
        swizzler<0>::type r;
        swizzler<1>::type g;
        swizzler<2>::type b;
    };
    struct {
        swizzler<0>::type s;
        swizzler<1>::type t;
        swizzler<2>::type p;
    };
    ...
-----

== swizzle (continued)
[source, cpp]
-----
    ...
    swizzler<0, 0>::type xx, rr, ss;
    swizzler<0, 1>::type xy, rg, st;
    swizzler<0, 2>::type xz, rb, sp;
    swizzler<1, 0>::type yx, gr, ts;
    swizzler<1, 1>::type yy, gg, tt;
    swizzler<1, 2>::type yz, gb, tp;
    swizzler<2, 0>::type zx, br, ps;
    swizzler<2, 1>::type zy, bg, pt;
    swizzler<2, 2>::type zz, bb, pp;
    ...
-----

== ...more swizzle
[source, cpp]
-----
    ...
    swizzler<0, 0, 0>::type xxx, rrr, sss;
    swizzler<0, 0, 1>::type xxy, rrg, sst;
    swizzler<0, 0, 2>::type xxz, rrb, ssp;
    swizzler<0, 1, 0>::type xyx, rgr, sts;
    swizzler<0, 1, 1>::type xyy, rgg, stt;
    swizzler<0, 1, 2>::type xyz, rgb, stp;
    swizzler<0, 2, 0>::type xzx, rbr, sps;
    swizzler<0, 2, 1>::type xzy, rbg, spt;
    swizzler<0, 2, 2>::type xzz, rbb, spp;
    swizzler<1, 0, 0>::type yxx, grr, tss;
    swizzler<1, 0, 1>::type yxy, grg, tst;
    swizzler<1, 0, 2>::type yxz, grb, tsp;
    ...
-----

== ...even more swizzle!
[source, cpp]
-----
    ...
    swizzler<2, 1, 2, 0>::type zyzx, bgbr, ptps;
    swizzler<2, 1, 2, 1>::type zyzy, bgbg, ptpt;
    swizzler<2, 1, 2, 2>::type zyzz, bgbb, ptpp;
    swizzler<2, 2, 0, 0>::type zzxx, bbrr, ppss;
    swizzler<2, 2, 0, 1>::type zzxy, bbrg, ppst;
    swizzler<2, 2, 0, 2>::type zzxz, bbrb, ppsp;
    swizzler<2, 2, 1, 0>::type zzyx, bbgr, ppts;
    swizzler<2, 2, 1, 1>::type zzyy, bbgg, pptt;
    swizzler<2, 2, 1, 2>::type zzyz, bbgb, pptp;
    swizzler<2, 2, 2, 0>::type zzzx, bbbr, ppps;
    swizzler<2, 2, 2, 1>::type zzzy, bbbg, pppt;
    swizzler<2, 2, 2, 2>::type zzzz, bbbb, pppp;
};
-----

== `swizzler<>` design

TODO: ...

== Operators and Functions

TODO: ...

== Limitations and Problems

TODO: ...

== Solutions

TODO: ...

== the `matrix<>` datatype

TODO: ...

== Prior Art

TODO: ...

== Results

== !

//TODO: doesn't work
//[.step]
...but first: Crash Course into Procedural Graphics!

NOTE: Courtesy of @ReinderNijhoff https://www.shadertoy.com/view/4dSfRc

[%notitle, background-image="img/tutorial/step_1.png"]
== raymarch tutorial step 1
[%notitle, background-image="img/tutorial/step_2.png"]
== raymarch tutorial step 2
[%notitle, background-image="img/tutorial/step_3.png"]
== raymarch tutorial step 3
[%notitle, background-image="img/tutorial/step_4.png"]
== raymarch tutorial step 4
[%notitle, background-image="img/tutorial/step_5.png"]
== raymarch tutorial step 5
[%notitle, background-video="vid/raymarch.mp4", options="loop,muted"]
== raymarch tutorial step 6
[%notitle, background-image="img/tutorial/step_7.png"]
== raymarch tutorial step 7
[%notitle, background-image="img/tutorial/step_8.png"]
== raymarch tutorial step 8

== Showcase

[%notitle]
== Hardware
- GPU on desktop PC
 * https://www.shadertoy.com/user/valentingalea
 * Nvidia GeForce 1060
 * 1080p
- CPU on desktop PC
 * AMD FX 8350 8-core 4.00 GHz
 * Microsoft Visual C++ 15.7.6
 * 320x240px

[%notitle]
== Hardware (continued)
- CPU mobile phone
 * Samsung Galaxy S7
 * C4Droid app (https://play.google.com/store/apps/details?id=com.n0n3m4.droidc)
 * GCC 7.2.0
 * 100x100px

[%notitle, background-video="vid/planet.mp4", options="loop,muted"]
== Planet (GPU)

== Planet (CPU)

|==========================================================================================
| image:img/showcase/pc_planet.png[Planet(PC)] | image:img/showcase/droid_planet.jpg[Planet(Droid), 300, 300]
| Desktop PC                          | Mobile Phone
| .1 FPS :(                           | 5 FPS
|==========================================================================================

[%notitle, background-video="vid/clouds.mp4", options="loop,muted"]
== Clouds (GPU)

== Clouds (CPU)

|==========================================================================================
| image:img/showcase/pc_clouds.png[Clouds(PC)] | image:img/showcase/droid_clouds.jpg[Clouds(Droid), 300, 300]
| Desktop PC                          | Mobile Phone
| 1 FPS                               | 8 FPS
|==========================================================================================

== Vinyl Turntable (GPU)

TODO: capture video

== Vinyl Turntable (CPU)

TODO: capture pics/vid

== Egg (GPU)

TODO: capture video (disable 3d and longer)
TODO: only on GPU

== The End
image:img/icon/twitter.png[Twitter, 64, 64] @valentin_galea

image:img/icon/github.png[Github, 64, 64] https://github.com/valentingalea/

image:img/sd-brand/SD-logo-white-orange.svg[SD, 128, 128] https://www.splashdamage.com/

== Attribution

- Piotr Gwiazdowski @gwiazdorrr for original inspiration and help
- Shading and Renderman: Jaume Sanchez | @thespite
- Motivation Shaders: Inigo Quilez https://www.shadertoy.com/view/ld3Gz2 https://www.shadertoy.com/view/ldScDh https://www.shadertoy.com/view/4ttSWf
- GPU pipeline: https://open.gl/ (CC BY-SA 4.0) 
- All other images under "Fair Use"/"Fair Dealing"
