= The Badlands of C++ : Professional Game Development

Who am I
--------
Valentin Galea - `@valentin_galea` - more than 10 years doing mobile, indie and AAA games

image:https://raw.githubusercontent.com/valentingalea/research/master/badlands/img/vanity_plate.png["Games worked on", align="center"]

Currently at Splash Damage, here in London.

What I will talk about
----------------------
[quote, Wikipedia]
AAA games [...] informal classification used for video games with the highest development budgets and levels of promotion

image:https://raw.githubusercontent.com/valentingalea/research/master/badlands/img/AAA.jpg["AAA games", align="center", width="720"]

What I will talk about (continued)
----------------------------------
[quote, Wikipedia]
indie games [...] created without the financial support of a publisher

image:https://raw.githubusercontent.com/valentingalea/research/master/badlands/img/indie.jpg["indie games", align="center", width="720"]

What I will talk about (continued)
----------------------------------
[quote, Wikipedia]
mobile games [...] played on a feature phone, smartphone, smartwatch, PDA, tablet computer

image:https://raw.githubusercontent.com/valentingalea/research/master/badlands/img/mobile.jpg["mobile games", align="center", width="720"]

What I will talk about (continued)
----------------------------------
Most about AAA games because

* have the most experience with
* they are the most process driven
* use C++ in very special and quirly ways (the purpose of the talk)

Indie games dev shares some elements with the above

Mobile games are usually written in something else: Objective C, C# - but they also do idiomatic C++

What I won't talk about
-----------------------
* Scripting languages / visual scripting
- normally AAA games supplement the C++ with a simpler language for gameplay and level scripting: Lua, Python or bespoke
- worse: visual scripting spaghetti
* Tools
- these can be written in C++, but a lot of them are in C# or Python
* Build / Package of game data
- a nightmare on its own

It's a secret
-------------
image:https://raw.githubusercontent.com/valentingalea/research/master/badlands/img/zelda_secret.gif["Secret", align="center"]

For obvioulsy reason, AAA development is covered in secrecy, source code included.

It's a secret (2)
-----------
`id software` notably broke the trend and released the source code of all their _Doom_ and _Quake_ games.

The rest of the industry didn't follow suit. Even `id` stopped after being aquired by the publisher Bethesda.

It's a secret (3)
-----------------
Some of the modern AAA game engines like _Unreal Engine 4_ and _CryEngine_ changed their licensing and the're open now.

.Disclamer
For these reason I can talk only from my direct experience, and focus on `UE4`.

A glimpse of good
-----------------
.Source code snippet from _Doom 3_
image:https://raw.githubusercontent.com/valentingalea/research/master/badlands/img/doom3.png["Doom 3 src", align="center"]

A glimpse of bad
----------------
.Source code snippet from _CryEngine_
image:https://raw.githubusercontent.com/valentingalea/research/master/badlands/img/cryengine.jpg["CryEngine 3 src", align="center"]

//TODO: maybe show some UE4: like UEngine::Exec or FilterEdPoly

Philosophy
----------
Games need to run

* at least 30 Fps - 33 ms per frame
* 60+ FPS very desirable (obligatory for multiplayer) - 16 ms per frame

Everything is centered around achieving this frame time while pushing the limit graphics and gameplay wise.

Stability can sometimes be sacrificed. (SPEAKER: a crash is forgiven if it doesn't corrupt the save data!)

Concern for uptime is limited.

Low latency but throughput more important - got to push millions of pixels to the screen!

Platform - Compiler
-------------------
By far and large Windows centric development - even for consoles.

.MSVC
- is overwhelmingly used, almost de facto standard
- sometimes quite old versions, by now 2013+
- before C++11 lots of code depended on Microsoft quirks (SPEAKER: 2 phase lookup etc)

.GCC
- rarely used on PC : mainly dedicated servers, or the odd Linux port
- prev gen consoles had vendor specific variants

.clang
- Playstation 4 uses it exclusively (with LLVM backend)

Platform - IDE
--------------
Again Microsoft drives it:

.Visual Studio
- used everywhere: PC, Xbox One, PS4
- most common extention: Visual Assist X - only way to cope with code completion

.Others
- SN Systems: proprietary EDG front end for Sony until PS4
- Metroworks CodeWarrior for Nintendo consoles
- XCode - No :)

Project size/LOC
----------------
AAA studios can be hundreds of people across various continents, lots of wheel reinventions, so the amount of code quickly skyrockets.

Factor in the _legacy_ of francize games and sequels.

[quote, CppCon 2014: Nicolas Fleury "C++ in Huge AAA Games"]
_______
Assassin's Creed Unity:

* 6.5 M C++ LOC for entire team code.
* 9 M more C++ LOC from outside project.

Rainbow Six: Siege:

* 3.5 M C++ LOC for engine code from game team.
* 4.5 M C++ LOC from Technology Group.
_______

Compilation
-----------
Compilation and linking are usually dreadfully slow.

Optimizations are on by default, rarely debug builds are interactive.

Various tricks:

* `#pragma optimize` on/off "islands"
* only specific modules are debug
* mastery of reading optimized disassembly :)

End result usually a single executable - size is ridiculous!

Compilation (continued)
-----------------------
Some mitigation methods:

.Unity builds
Combine all or lots of source files into a couple of gigantic .cpp units

.Distributed compilation
Use solution like `FastBuild` or `Incredibuild` to effectively create compilation farms

.Throw hardware at it
In a studio, programmers are spoiled: fastest CPU's, multiple SSD's etc

Flavours of C++
---------------
Tradionally was very C\+\+98 but by now C++11 is baseline.

C++14 in some select corners. The major engines help with this - `UE4` enables it by default.

Due to differences in people's experience, personality and time availability, adoption of the various new features and techniques is slow.

At Splash Damage, we try to counter this by:

* running a series of internal talks like "C++11/14 for game dev"
* I run a newsletter about best practices and modern C++

Templates
---------
Generally there is a tendency to look down on templates. Changing now that compilers are better and features improved.

Template-metaprogramming still is seen as black magic and highly discurouged.

Because of project size, you can find isolated islands where they thrive.

Some people will still use macros where `template` or `constexpr` functions will be perfectly adequate (SPEAKER: ugly ex I remember: overload eq ops for hashmap keys)

OOP is king
-----------
All game code is universally OOP driven, with polymorphism being lingua-franca. "What is a v-table?" is the most asked interview question!

That's because Entity-Component-Systems are prevalent in gameplay code. Everything is a hierachy of `Entity`, `Node` or `Object`'s.

Components do virtual `Update`, `Tick`, `Pump` or `Think`!

Communication happens either via tight coupling or delegate/event systems (usually heavily macro'ed!) 

Alternatives to OOP
-------------------
Functional style 'monad' continuations are emerging.

Lots of systems like IO, saving/loading, rendering, services management are multithreaded - various paradigms:

* home-grown async task libraries
* Parallel Patterns Library (PPL) from Microsoft
* Threading Building Blocks from Intel
* very rarely the standard `future` and `promise` - usually every game engine has own equivalents

STL
---
Very low adoption. No game I know shipped with STL containers. Bespoke alternatives overwhelmingly used, due to:

* specific allocation needs (and poor support for allocators pre C++11)
* associated (or percieved) bloat

.EASTL from Electronic Arts
A video game specific implementation of STL +
https://github.com/electronicarts/EASTL

.SG14 group
Video games and embedded programming sub-group within the ISO C++ Standard's Study Group +
Tries to propose new, optimized containers, data structures even language changes.

STL (continued)
---------------
Very rare use of `algorithm`. True generic programming - in Alex Stepanov way - not used. (SPEAKER: mention Sean Parent's talk)

Every studio/engine reinvents the string wheel (so no `std::string`):

* previous implementations were bad or made awkward choices (SPEAKER: copy on write on GCC)
* specific localization needs - ties with game data

The `Iterator` concept is copied and reimplemented - if nothing else just to enable ranged-for's.

Boost
-----
Very frowned upon and sometimes even laughed at - due to increase in compilation and difficulty to integrate.

TODO: image crop of: https://pbs.twimg.com/media/C5TrLWPWMAAQGex.jpg

Sometimes cherry pick libraries with the `bcp` tool.

Exceptions
----------
Almost never used due to speed penalties of `throw`-ing and `catch`-ing.

Usually (and always during dev time) a hard exit is requested on error.

That means errors in constructors cannot be handled. Usual solution is to have 'Create'/'Instantiate'/'Begin' etc (SPEAKER: this is also due to GC and serialization)

That's why people don't care or don't know about `noexcept`.

RTTI
----
Seldom used - normally turned off by default because it bloats the modules size.	

Very rare use of `dynamic_cast` - usually reimplemented manually via custom reflection.

Reflection
----------
A lot of games have an involved reflection sytem due to:

* close live link with editors/tools: values inspection, code hot reload
* serialization for loading/saving; versioning
* network replication, RPC's
* garbage collection

Custom, individual solutions:

* pre-processor based decorations that both annnote code and generate registration calls
* template metaprogramming for same purpose
* mini IDL's that generate additional cpp/h files

Reflection (continued)
---------------------
Some examples:

image:https://raw.githubusercontent.com/valentingalea/research/master/badlands/img/reflection.png["reflection", align="center"]

TODO: more

Patterns
--------
Common patterns use:

.Singleton
Anti-pattern of choice. Spreads like plague because lots of systems usually have only 1 active representation: _Camera_, _Player_, _AI Manager_ etc

.Policy based design
Example of usage: container allocators, rendering & drawing, game object composition 

.Visitor
To implement double dispatch.

Coding style
------------
Every studio has a set of guidelines or a complete style. Some of them recommend things that would really upset a C++ purist. (TODO: expand more)

CamelCase rules the nation.

Namespaces are not prefered; instead everything has a game specific prefix: _CShooterComponent_, _CShooterObject_, _TShooterItem_ etc

K&R (or "egyptian") style of braces very frowned upon - Allman is almost always used.

Closing
-------
TODO: some sort of conclusion

TODO: We hire & promotion