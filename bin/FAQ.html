<h4>C++11</h4>
<h5>What are <em>closures</em>? What are <em>lambdas</em>?</h5>
<p>Lambda = anonymous local function</p>
<p>Closure = lambda + reference to the environment (a table storing a reference to each of the non-local captured variables)</p>
<h5>What is a <em>move assignment</em> operator? When to use it?</h5>
<p>Tied to the concept of rvalue-reference (or xvalue)</p>
<p>The move assignment operator is called whenever it is selected by overload resolution, e.g. when an object appears on the left side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.</p>
<p>Move assignment operators typically &quot;steal&quot; the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, move-assigning from a std::string or from a std::vector leaves the right-hand side argument empty.</p>
<p>More <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics</a></p>
<h5><em>std::move()</em></h5>
<p>Obtains an rvalue reference to its argument and converts it to an xvalue.</p>
<p>Code that receives such an xvalue has the opportunity to optimize away unnecessary overhead by moving data out of the argument, leaving it in a valid but unspecified state.</p>
<p>Basically it's just a cast:</p>
<pre><code>template&lt;typename _Tp&gt;
constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; move(_Tp&amp;&amp; __t) noexcept
{
    return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t);
}</code></pre>
<h5>What are the <em>atomic types</em> and how would you use them?</h5>
<p>It allows lockless concurrent programming.</p>
<p>Each atomic operation is indivisible with regards to any other atomic operation that involves the same object. Atomic objects are the only C++ objects free of data races; that is, if one thread writes to an atomic while another thread reads from it, the behavior is well-defined.</p>
<hr />
<h4>git</h4>
<h5>reset</h5>
<blockquote>
<p>git reset \<mode\> \<commit\></p>
</blockquote>
<p><mode> can be</p>
<ul>
<li><em>---soft</em> doesn't touch anything, just moves the head to the \<commit\><br /></li>
<li><em>---mixed</em> (the default) only touches the index i.e. undo add/mark for commit<br /></li>
<li><em>---hard</em> reverts both the index and the working tree to the \<commit\> i.e. total undo!</li>
</ul>
<h5>timestamp spec</h5>
<blockquote>
<p><script type="text/javascript">
<!--
h='&#x7b;&#34;&#x61;&#110;&#x79;';a='&#64;';n='&#98;&#114;&#x61;&#110;&#x63;&#104;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+'branch@{&quot;any'+'<\/'+'a'+'>');
// -->
</script><noscript>&#98;&#114;&#x61;&#110;&#x63;&#104;&#64;&#x7b;&#34;&#x61;&#110;&#x79;&#32;&#40;&#98;&#114;&#x61;&#110;&#x63;&#104;&#32;&#x61;&#116;&#32;&#x7b;&#34;&#x61;&#110;&#x79;&#x29;</noscript> date format&quot;}</p>
</blockquote>
<h5>detach head</h5>
<blockquote>
<p>git checkout <em>timestamp-spec</em></p>
</blockquote>
<h5>change default push mode</h5>
<blockquote>
<p>git config --global push.default <em>mode</em></p>
</blockquote>
<ul>
<li><em>nothing</em><br /></li>
<li><em>matching</em> - all branches having the same name in both ends (default)<br /></li>
<li><em>upstream</em> - the current branch to its upstream branch<br /></li>
<li><em>simple</em> - same as <em>upstream</em> but only if name is the same<br /></li>
<li><em>current</em> - the current branch to a branch of the same name</li>
</ul>
<h5>external tools</h5>
<blockquote>
<p>git config --global mergetool.p4merge.path <em>path</em></p>
</blockquote>
<blockquote>
<p>git config --global merge.tool p4merge</p>
</blockquote>
<h5>ref specs</h5>
<p><em>r1..r2</em> equiv to <em>^r1 r2</em> - comits reachable from r2 but not r1 aka set difference</p>
<p><em>r1...r2</em> equiv <em>r1 r2 --not $(git merge-base --all r1 r2)</em> - commits reachable from either r1 or r2 but not both aka symmetric difference</p>
<h5>p4 git</h5>
<p><a href="http://answers.perforce.com/articles/KB_Article/Git-P4">http://answers.perforce.com/articles/KB_Article/Git-P4</a><br /><a href="http://ericlathrop.com/2012/12/how-to-set-up-git-p4-in-windows/">http://ericlathrop.com/2012/12/how-to-set-up-git-p4-in-windows/</a><br /><a href="http://git-scm.com/docs/git-p4">http://git-scm.com/docs/git-p4</a></p>
<h5>rebase</h5>
<ul>
<li>is done in the branch and that branch is applied on top of master<br /></li>
<li>on master u can do a fast-forward merge to sync up</li>
</ul>
<p>before:<br /><code>A---B---C topic              /     D---E---F---G master</code></p>
<p>after:<br /><code>A'--B'--C' topic                  /     D---E---F---G master</code></p>
<hr />
<h4>STL</h4>
<h5>containers speed</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Container</th>
<th style="text-align: left;">Implementation</th>
<th style="text-align: left;">Insert</th>
<th style="text-align: left;">Remove</th>
<th style="text-align: left;">Index</th>
<th style="text-align: left;">Find</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">vector</td>
<td style="text-align: left;">dynamic array</td>
<td style="text-align: left;">O(n)</td>
<td style="text-align: left;">O(n)</td>
<td style="text-align: left;">O(1)</td>
<td style="text-align: left;">O(log n)</td>
</tr>
<tr class="even">
<td style="text-align: left;">list</td>
<td style="text-align: left;">double link list</td>
<td style="text-align: left;">O(1)</td>
<td style="text-align: left;">O(1)</td>
<td style="text-align: left;">-</td>
<td style="text-align: left;">O(n)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">map</td>
<td style="text-align: left;">red-black b tree</td>
<td style="text-align: left;">O(log n)</td>
<td style="text-align: left;">O(log n)</td>
<td style="text-align: left;">O(1)</td>
<td style="text-align: left;">O(log n)</td>
</tr>
<tr class="even">
<td style="text-align: left;">hashmap</td>
<td style="text-align: left;">hash table</td>
<td style="text-align: left;">O(1)</td>
<td style="text-align: left;">O(1)</td>
<td style="text-align: left;">O(1)</td>
<td style="text-align: left;">O(1)</td>
</tr>
</tbody>
</table>
<hr />
<h4>C++ syntax notes</h4>
<h5><em>static</em> - all the different meanings?</h5>
<ol>
<li>at <em>file scope</em>: signifies &quot;internal-linkage&quot; i.e. not shared between translation units<br /></li>
<li>at <em>function scope</em>: variable retains value between function calls<br /></li>
<li>at <em>class scope</em>: signifies independence of class instance</li>
</ol>
<h5><em>const</em> and <em>mutable</em></h5>
<p>Const member function doesn't alter the data it operates on; except the one marked as <em>mutable</em></p>
<h5>default <em>copy constructor</em> and <em>assignment operator</em> - when to override?</h5>
<p>Rule of 3 in C++03 / Rule of 5 in C++11<br />When the class needs to be copy/move assignable - that is when it needs to be <em>cloneable</em> i.e. has non-shareable data</p>
<h5><em>volatile</em> keyword</h5>
<p>Depends on language and compiler. Usually marks <em>atomicity</em> for data (but not guarantees it): reads from threads are guaranteed to have latest; marks that variable can be modified &quot;externally&quot;</p>
<h5><em>restrict</em> keyword</h5>
<p><a href="http://stackoverflow.com/questions/776283/what-does-the-restrict-keyword-mean-in-c">http://stackoverflow.com/questions/776283/what-does-the-restrict-keyword-mean-in-c</a></p>
<p>Optimisation hint to limit pointer aliasing and aid caching - it means a particular data is accessed only thru that pointer thus making optimisations like storing the ptr value in a registry for subsequent access</p>
<h5><em>in place</em> new</h5>
<p>Allows to explicitly specify the memory management of individual objects, i.e. their &quot;placement&quot; in memory.</p>
<p>new (expression) <type> [(arguments)]; for example:</p>
<pre><code>char buffer[] = new char[256];
string *str = new (buffer) string(&quot;Hello world&quot;);</code></pre>
<p>there is no placement delete syntax (but both <em>new</em> and <em>delete</em> functions can be overrided to specify the in-place)</p>
<h5><em>typename</em> keyword</h5>
<ol>
<li>alias for the <em>class</em> keyword when declaring template parameters<br /></li>
<li>a method to indicate that a dependent name is a type</li>
</ol>
<p>If the compiler can't tell if a dependent name (one that contains a template parameter) is a value or a type, then it will assume that it is a value.</p>
<pre><code>template &lt;typename T&gt;
void foo() {
   T::bar * p; // won&#39;t compile, because without the typename prefix it will be interpreted as a multiplication
}
 
struct Gotcha {
   typedef int bar;
};

foo&lt;Gotcha&gt;();</code></pre>
<h5>SFINAE</h5>
<p>If an error occurs during the substitution of a set of arguments for any given template, the compiler removes the potential overload from the candidate set instead of stopping with a compilation error</p>
<p><a href="http://en.wikipedia.org/wiki/SFINAE">http://en.wikipedia.org/wiki/SFINAE</a></p>
<h5>Meyers Singleton</h5>
<pre><code>static Singleton&amp; Instance()
{
  static Singleton theSingleton; // initialized at first function call
  return theSingleton;
}</code></pre>
<hr />
<h4>C++ virtual</h4>
<h5>What is a <em>virtual</em> function?</h5>
<p>A virtual function allows derived classes to replace the implementation provided by the base class.</p>
<p>When you refer to a derived class object using a pointer or a reference to the base class, you can call a virtual function for that object and execute the derived class's version of the function. Virtual functions ensure that the correct function is called for an object, regardless of the expression used to make the function call</p>
<h5><em>pure</em> virtual function</h5>
<p>A virtual function that is required to be implemented by a derived class.</p>
<p>Classes containing pure virtual methods are termed &quot;abstract&quot;; they cannot be instantiated directly.</p>
<h5>virtual <em>destructor</em> - when/why?</h5>
<p>At the root of a class hierarchy to insure proper cleanup</p>
<h5>virtual call in <em>assembly</em></h5>
<pre><code>mov eax, dword ptr [this]
mov edx, dword ptr [eax]
mov eax, dword ptr [edx+4]
mov ecx, dword ptr [this]
call eax</code></pre>
<h5>co-variant return types</h5>
<p><a href="http://katyscode.wordpress.com/2013/08/22/c-polymorphic-cloning-and-the-crtp-curiously-recurring-template-pattern/">http://katyscode.wordpress.com/2013/08/22/c-polymorphic-cloning-and-the-crtp-curiously-recurring-template-pattern/</a></p>
<hr />
