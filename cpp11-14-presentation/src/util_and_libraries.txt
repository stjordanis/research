<<Utilities & Libraries>>
-------------------------

std::tuple
----------
A kind of generalized anonymous `struct`. For only 2 members there's also `std::pair`. 

Useful to return multiple values from functions (ex: data + error flag)

[role="incremental"]
[source,cpp]
/* tuple */                                      /* struct equivalent */
std::tuple<int, float, std::string>              struct tuple {
                                                     int _0;
                                                     float _1;
                                                     std::string _2;
                                                 };

[role="incremental"]
[source,cpp]
/* tuple */                                      /* struct equivalent */
auto t = std::make_tuple(1, 3.14f, "hello"s);    auto t = tuple {1, 3.14f, "hello"};

[role="incremental"]
[source,cpp]
/* tuple */                                      /* struct equivalent */
std::get<0>(t);                                  t._0;
std::get<float>(t); // C++14 only                no equivalent 

[role="incremental"]
TIP: UE4 equivalent is TTuple

// http://www.oracle.com/technetwork/articles/servers-storage-dev/c-array-containers-2252536.html

std::tuple - examples
---------------------

[role="incremental"]
[source,cpp]
std::tuple<int, int, int, int> CalculateSize() {
    // logic ...
    return std::make_tuple(x, y, width, height);
}

[role="incremental"]
[source,cpp]
std::tuple<Widget, bool> GetWidget() {
    Widget work{};
    // logic ...
    if (error) {
        return std::make_tuple(Widget{}, false);
    } else {
        return std::make_tuple(std::move(work), true);
    }
}

[role="incremental"]
[source,cpp]
auto w = GetWidget();
if (std::get<bool>(w)) {
    std::get<Widget>(w).method();
}

std::tuple - more examples 
--------------------------
[role="incremental"]
[source,cpp]
std::tuple<int, int, int, int> CalculateSize() { ... }
;
int x, y, witdh, height;
std::tie(x, y, witdh, height) = CalculateSize();

[role="incremental"]
[source,cpp]
std::tuple<int, int, int, int> CalculateSize() { ... }
;
int x, y;
std::tie(x, y, std::ignore, std::ignore) = CalculateSize();


std::unique_ptr
---------------
Smart pointer that retains sole ownership of an object and destroys it when it goes out of scope.

No two `unique_ptr` instances can manage the same object.

[role="incremental"]
[source,cpp]
std::unique_ptr<int> p1 { new int {42} };
std::unique_ptr<int> p1 = std::make_unique<int>(42); // since C++14

[role="incremental"]
No overhead like normal pointer but can optionally store a custom deleter function.

[role="incremental"]
Typical usage:

[role="incremental"]
* ownership (acquiring / passing) of dynamically allocated objects 
* safety by guaranteeing deletion on both
** normal exit
** exit through exception/error
* as the element type in move-aware containers, such as `std::vector`, which hold pointers to dynamically-allocated objects 

[role="incremental"]
TIP: UE4 equivalent is TUniquePtr.

std::unique_ptr - examples
--------------------------
[role="incremental"]
[source,cpp]
----
{
    std::unique_ptr<int> p1 = std::make_unique<int>(42);

    std::unique_ptr<int> p2 = p1; // Compile error!!! cannot copy
    std::unique_ptr<int> p3 = std::move(p1); // Transfers ownership.
                                             // p3 now owns the memory and p1 is rendered invalid.

} // end of scope: p3 will be destroyed, p1 is empty so nothing happens
----

[role="incremental"]
[source,cpp]
----
{
    auto file_closer = [](FILE* f) {
        ::fclose(f);
    };

    std::unique_ptr<FILE, decltype(file_closer)> file = { ::fopen("output.bin", "wb"), file_closer };

    if (file) {
        ::fwrite(&data, sizeof(data), 1, file.get());
    }
} // end of scope: file will be closed gracefully
----

std::shared_ptr
---------------
Smart pointer that retains shared ownership of an object. 

The referenced object will be destroyed _only_ when all copies of the `shared_ptr` have been destroyed.

[role="incremental"]
[source,cpp]
std::shared_ptr<int> p1 { new int {42} };
std::shared_ptr<int> p1 = std::make_shared<int>(42);
	
[role="incremental"]
More overhead than normal pointer (due to need of storing the reference count). Can also contain a custom deleter function.

[role="incremental"]
Typical usage:

[role="incremental"]
* safe shared ownership of data
* multi-threaded safety of shared access (but not modification)

[role="incremental"]
TIP: UE4 equivalent is TSharedPtr.

std::weak_ptr
-------------
Smart pointer that holds a non-owning ("weak") reference to an object that is managed by `std::shared_ptr`.

Models temporary ownership:

* when an object needs to be accessed only if it exists
* and it may be deleted at any time by someone else

[role="incremental"]
To actually be used it will be converted into a temporary `std::shared_ptr`.

[role="incremental"]
TIP: UE4 equivalent is TWeakPtr.

std::shared_ptr/weak_ptr - examples
-----------------------------------
[source,cpp]
----
{
    std::shared_ptr<int> p1 = std::make_shared<int>(5);

    {
        std::shared_ptr<int> p2 = p1;  // add a new reference
        std::weak_ptr<int> wp1 = p1;   // doesn't count as new reference
        
        int n = *p2;                   // dereference like normal pointer

        int q = wp1.expired() ? 0 : *(wp1.lock()); // safe dereference

    } // end of this scope, p2 and wp1 destroyed but not the owned object 

} // p1 is destroyed and so is the object
----

