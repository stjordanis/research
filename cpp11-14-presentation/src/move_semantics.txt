<<Move Semantics>>
------------------

move semantics - lvalues/rvalues
--------------------------------
Every C++ statement is either an _lvalue_ or an _rvalue_.

[role="incremental"]
_lvalues_ generally sit on the left of =, are always named, persist and you can take their address.

[role="incremental"]
_rvalues_ generally sit on right of =, are temporary i.e. they don't persist beyond the expression that uses them.

[role="incremental"]
In C++03 you cannot do much with _rvalues_, you need to "capture" them by assignment if you want to use them otherwise they go away.

// https://msdn.microsoft.com/en-us/library/f90831hc.aspx
// http://blog.smartbear.com/development/c11-tutorial-explaining-the-ever-elusive-lvalues-and-rvalues/

move semantics - lvalue/rvalue - examples
-----------------------------------------
[source,cpp]
/*lvalue*/ /*rvalue*/
int x      = 3 + 4;
*ptr;      // lvalue
&x;        // rvalue: the address of x
"hello";   // rvalue: literal

[role="incremental"]
[source,cpp]
int& func();
int func2();
func();     // lvalue, the call will return a meaningful address
func2();    // rvalue - an 'invisible' temporary is returned

[role="incremental"]
[source,cpp]
std::string("hello");   // rvalue
new int;                // rvalue
const widget y {};      // lvalue
int i;                  // lvalue
((i < 3) ? i : x) = 7;  // correct statement: the conditional operator returns lvalue

move semantics - rvalue references
----------------------------------
C++11 introduces _rvalue_ references: `<identifier> &&`

[role="incremental"]
They are most useful as arguments to functions in order to work with temporaries as well rather than "final result".

[role="incremental"]
Also now functions can return _rvalue_ references to optimise the passing around of the return value.

[role="incremental"]
To leverage this, _move constructors_ and _move assignment operator_ are introduced.

[role="incremental"]
NOTE: In the context of template deduction && means something different: a "universal reference" used to implement perfect forwarding: that is ability to accept both _lvalue_ and _rvalue_ arguments.
[role="incremental"]
[source,cpp]
template<class T> void func(T&& arg); // not a rvalue reference, but could be!

move semantics - example
------------------------
[source,cpp]
-------------------------------------------------------------------------------
struct MemoryPage {
    void * address;
    size_t size;
    
    // appropriate constructor & destructor
    MemoryPage() {...}
    ~MemoryPage() {...}
    
    // copy constructor and assignment operator
    MemoryPage(const MemoryPage& other) {
        memcpy(address, other.address, other.size);
        size = other.size;
    }
    MemoryPage& operator=(const MemoryPage&) {
        // same expensive memcpy...
    }
-------------------------------------------------------------------------------

move semantics - example (continued)
-----------------------------------
[source,cpp]
-------------------------------------------------------------------------------
    // move constructor and move assignment operator
    MemoryPage(MemoryPage&& other) {
        // trivial swap of data
        address = other.address;
        size = other.size;
        // reset other, making it valid but empty
        other.address = nullptr;
        other.size = 0;
    }
    MemoryPage& MemoryPage::operator=(MemoryPage&& other) {
        // release the current object's resources
        delete[] address;
        size = 0;
        // swap from other and empty it just like in the copy constructor
        // ...
    }
}
-------------------------------------------------------------------------------

move semantics - usage (continued)
----------------------------------
[role="incremental"]
[source,cpp]
std::vector<MemoryPage> pages;
pages.push_back(MemoryPage());                  // avoid copy, insert directly
pages.push_back(MemoryPage());                  // again
pages.emplace_back((void *)0xFF02320, 1024);    // even better: C++11 method that does perfect forwarding and just constructs in-place (no move)

[role="incremental"]
_lvalues_ don't trigger move semantics, but they can be forced to with `std::move` (which is a fancy static_cast to &&)

[role="incremental"]
NOTE: within functions, arguments are always _lvalues_, even if originally at the call site a _rvalue_ was passed

[role="incremental"]
[source,cpp]
MemoryPage p(...);
pages.push_back(p);                // calls copy constructor
pages.push_back(std::move(p));     // calls move constructor, p is now useless on its own

[role="incremental"]
NOTE: UE4 version of std::move is called MoveTemp

