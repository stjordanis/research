include::style.inline.txt[]

=== optional

Handling errors is an integral part of everyday programing yet still there isn't a true elegant method of doing it. Some might say that there is, and it's called throwing exceptions, but here we are in game dev and we hate exceptions with a passion!

Let's suppose we define our own square root function:

[source]
float squareRoot(float number);

It is well known that this is invalid for negative values. How do you report that to the user? We decided throwing an error is not allowed. Have some sort of guard value?

[source]
if (squareRoot(x) != NaN)
	/* do work */

This is fragile and actually very difficult for floating points as in this example. Let's rewrite it the old fashioned C way:

[source]
bool squareRoot(float in, float &out);

Ugly but at least we can do this now:

[source]
float result = 0.f;
if (squareRoot(x, result))
	/* do work */

Fortunately there is a construct upcoming in C++17 to help with all this: `std::optional`. As the name suggests this is a small structure that can either have a `T` or not. Let's rewrite the function to take advantage of this:

[source]
std::optional<float> squareRoot(float number);

Beautiful! So the checking is pretty seamless, because optional has all sorts of utility functions and conversions to bool:

[source]
-------------------------------------------------------------------------------
if (squareRoot(x))
	/* do work */

auto result = squareRoot(x);
if (result.has_value())
	result.value();

if (auto result = squareRoot(x))
	*result; // a dereference operator is also provided
	
if (auto result = squareRoot(x); result.has_value()) // C++17 style of the above
	/* do work */
-------------------------------------------------------------------------------			

All modern compilers support it. Visual Studio added it as of 2017. There is an alternative implementation in Boost (in fact this was the inspiration for the standard one).

If you are working with Unreal Engine 4, it has its own flavour called `TOptional`. Here's the equivalent of the above examples in UE4:

[source]
-------------------------------------------------------------------------------
TOptional<float> squareRoot(float number);

auto result = squareRoot(x);
if (result.Is_Set())
	result.GetValue();
-------------------------------------------------------------------------------

=== variant

C++ inherited from C the union construct: basically a struct that packs together all its members in the same space (sized as the largest member). It's quite useful to group things like that and optimize space, or to have heterogeneous containers.

Unfortunately it's very limited due to its specific requirements of what you can store - it used to work only with POD (plain-old-data) members, although C++11 and above relaxed this:

[source]
-------------------------------------------------------------------------------
union Bundle
{
	int someInt;
	float someFloat;
	std::string someName; // illegal in C++98, valid in C++11
};
-------------------------------------------------------------------------------

By allowing this, it puts more burden on the user: the special functions like constructors, destructors etc are deleted and the user has to redefine them based on the usage.

I can talk more about this, but that's not the point. I want to show a better structure introduced as of C++17: http://en.cppreference.com/w/cpp/utility/variant[std::variant].

It is a type-safe, more powerful equivalent of the union, that never dynamically allocates memory - everything is stored in-place.

[source]
std::variant<int, float, std::string> bundle;

You can now assign values into it, each new one destroying and overwriting the old one:

[source]
bundle = 42; // now contains an int
bundle = 3.14f; // now contains a float
bundle = "hello"; // now contains a string, the previous values are gone

One can retrieve values out of it in various ways:

[source]
std::get<int>(bundle);
std::get<1>(bundle); // gets the float

Of course you have to be mindful of what you last put inside, otherwise these accessors will throw if there is a mismatch. Alternatively you can inquire and get:

[source]
if (auto value = std::get_if<float>(&bundle))
	do_work(*value);

Another useful utility function is the ability to "visit" the `variant` and react appropriately to what value it currently holds. This is a bit more advanced but do take a look at some http://en.cppreference.com/w/cpp/utility/variant/visit[examples here].

Other libraries have similar constructs, for example Unreal Engine 4 has its own `FVariant`, but it uses a different approach whereby it actually serializes the things put in.

Here is technique to have in mind for when you architecture systems - suppose you try to model something with multiple states:

[source]
-------------------------------------------------------------------------------
struct Player
{
	enum class State { ALIVE, DEAD, FIGHTING, IN_LOBBY };
	int health;
	bool isJumping;
	Item currentWeapon;
	Actor target;
	Actor killer;
	std::string url;
};
-------------------------------------------------------------------------------

Imagine all the boilerplate you will have to write to maintain all these states and make sure all the members are properly updated for each situation. Also look how the structure balloons in size every time you add new members. Instead why not remodel like this:

[source]
-------------------------------------------------------------------------------
struct Alive {
	bool isJumping;
	Item currentWeapon;
};

struct Dead {
	Actor killer;
};

struct Fighting {
	Actor target;
	Item currentWeapon;
};

struct InLobby {
	std::string url;
};

struct Player {
	int health;
	std::variant<Alive, Dead, Fighting, InLobby> state;
};
-------------------------------------------------------------------------------

I hope this speaks for itself as to the advantages it offers.

Until next time, +
Valentin
