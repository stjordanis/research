= Issue #7

Here we go for lucky number 7!

== Puzzle Answer

The correct answer for the last edition question was: Argument dependent lookup. Basically this means that function names and operators are also searched in the namespace of their arguments. So we don’t need to write this monstrosity:

[source]
std::operator<< (std::cout, "hello world!");

The fastest to reply correctly was Stefano Sampietro – congrats! He will get 1000 C++ points that he can spend at the Little Shop of C++ Horrors.

== optional

Handling errors is an integral part of everyday programing yet still there isn’t a true elegant method of doing it. Some might say that there is, and it’s called throwing exceptions, but here we are in game dev and we hate exceptions with a passion :D

Let’s suppose we define our own square root function:

[source]
float squareRoot(float number);

It is well known that this is invalid for negative values. How do you report that to the user? We decided throwing an error is not allowed. Have some sort of guard value?

[source]
if (squareRoot(x) != NaN)
	/* do work */

This is fragile and actually very difficult for floating points as in this example. Let’s rewrite it the old fashioned C way:

[source]
bool squareRoot(float in, float &out);

Ugly but at least we can do this now:

[source]
float result = 0.f;
if (squareRoot(x, result))
	/* do work */

Fortunately there is a construct upcoming in C++17 to help with all this: std::optional As the name suggests this is a small struct that can either have a T or not. Let’s rewrite the function to take advantage of this:

[source]
std::optional<float> squareRoot(float number);

Beautiful! So the checking is pretty seamless, because optional has all sorts of utility functions and conversions to bool:

[source]
-------------------------------------------------------------------------------
if (squareRoot(x))
	/* do work */

auto result = squareRoot(x);
if (result.has_value())
	result.value(); // *n works as well to get the value

if (auto result = squareRoot(x))
	/* do work */
if (auto result = squareRoot(x); result.has_value()) // C++17 style of the above
	/* do work */
-------------------------------------------------------------------------------			

Alas at the moment Visual Studio doesn’t support it (but latest Clang/GCC do). Support for it is coming. There is an alternative implementation in Boost (in fact this was the inspiration for the standard one), and Unreal Engine 4 has its own flavour called TOptional. Here’s the equivalent of the above examples in UE4:

[source]
-------------------------------------------------------------------------------
TOptional<float> squareRoot(float number);

auto result = squareRoot(x);
if (result.Is_Set())
	result.GetValue();
-------------------------------------------------------------------------------

== variant

C++ inherited from C the union construct: basically a struct that packs together all its members in the same space (sized as the largest member). It’s quite useful to group like that and optimise space, or have heterogeneous containers. Unfortunately it’s very limited due to its specific requirements of what you can store - it used to work only with POD (plain-old-data) members, although C++11 relaxed this:

[source]
-------------------------------------------------------------------------------
union Bundle
{
	int someInt;
	float someFloat;
	std::string someName; // illegal in C++98, valid in C++11
};
-------------------------------------------------------------------------------

but by allowing this, it puts more burden on the user: the special functions like constructors, destructors etc are deleted and the user has to redefine them based on the usage.

I can show/talk more about this, but that’s not the point. I want to show a better structure introduced in C++17 as well: std::variant. It is a type-safe, more powerful variant of the union (see what I did there?) and same as its counterpart, never dynamically allocates memory, everything is stored in-place.

[source]
std::variant<int, float, std::string> bundle;

You can now assign values into it, each new one destroying and overwriting the old one:

[source]
bundle = 42; // now contains int
bundle = 3.14f; // now contains float
bundle = "hello"; // now contains a string, the previous values are gone

Equally you can retrieve values out of it in various ways:

[source]
std::get<int>(bundle);
std::get<1>(bundle); // gets the float

Of course you have to be mindful of what you last put inside, otherwise these accessors will throw if there is a mismatch. Alternatively you can inquire and get:

[source]
if (auto value = std::get_if<float>(&bundle))
	do_work(*value);

Another useful utility function is the ability to “visit” the variant and react appropriately to what value it currently holds. This is a bit more advanced but do take a look at some examples here.

UE4 tries to mimic all this with FVariant, but sadly it does it poorly by using a different approach whereby it actually serializes the things put in.

Here is technique to have in mind where std::variant will save a lot of headache. Suppose you try to model something with multiple states:

[source]
-------------------------------------------------------------------------------
struct Player
{
	enum class State { ALIVE, DEAD, FIGHTING, IN_LOBBY };
	int health;
	bool isJumping;
	Item currentWeapon;
	Actor target;
	Actor killer;
	std::string url;
};
-------------------------------------------------------------------------------

Imagine all the boilerplate you will have to write to maintain all these states and make sure all the members are properly updated for each situation. Also look how the structure balloons in size every time you add new members. Instead why not remodel like this:

[source]
-------------------------------------------------------------------------------
struct Alive {
	bool isJumping;
	Item currentWeapon;
};

struct Dead {
	Actor killer;
};

struct Fighting {
	Actor target;
	Item currentWeapon;
};

struct InLobby {
	std::string url;
};

struct Player {
	int health;
	std::variant<Alive, Dead, Fighting, InLobby> state;
};
-------------------------------------------------------------------------------

I hope it speaks for itself as to the advantages it offers.

== Closing bits

Linked before above, but Visual Studio is preparing a new version (confusingly codenamed “15” – yeah the 2015 one is internal version 14). It will have a lot of improvements compiler wise – they are rewriting major portions of it, so it will support everything discussed here. You can check previews of it already.

Speaking of VS you can vote to request a major improvement of its debugger: support for IntelliTrace.

Until next time, +
Valentin
