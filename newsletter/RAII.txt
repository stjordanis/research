= Issue #4

Hi all,

Welcome to edition number 4 which is actually 2.0 because we have branding this time - thanks to the Media Team! (props to J and Mathew)

Today is about good and useful techniques that can enhance our daily C++. Without further ado, the first thing is:

== Topic #1 - The C++ Core Guidelines

This is a collaborative effort led by Bjarne Stroustrup, a set of tried-and-true guidelines, rules, and best practices about coding in C++. In their own words:

____
The aim of the guidelines is to help people to use modern C++ effectively. By "modern C++" we mean C++11 and C++14 (and soon C++17). In other words, what would you like your code to look like in 5 years' time, given that you can start now? In 10 years' time?
____

Here's the homepage: https://github.com/isocpp/CppCoreGuidelines and here are the guidelines themselves: https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md

I didn't yet go thru the whole list, but plan to, and then I will try to integrate most of it into my own coding.

== Topic #2 - RAII or how to clean up after yourself when you made a big mess

Suppose you have the following (pseudo)code that opens and reads a file. Pretty mundane but encountered a lot; also the following principles can be extrapolated in a lot of similar circumstances.

[source]
-------------------------------------------------------------------------------
void do_work()
{
       FILE *file_handle = open_file(...);
       if (!file_handle) {
              return;
       }

       int size = calculate_file_length(file_handle); // problem #1
       char *data_ptr = new char[size]; // problem #2

       int num_read = fread(data_ptr, sizeof(char), size, file_handle);
       if (!num_read) {
              fclose(file_handle);
              return; // problem #3
       }

       do_more_work(data_ptr);

       // problem #4
       delete[] data_ptr;
       fclose(file_handle);
}
-------------------------------------------------------------------------------

As you can see there are a lot of problems with this technique:

1. what if that utility function throws? Who closes the file handle?
2. avoid if you can naked pointers and naked allocations like that
3. the file read was unsuccessful, we tried to clean up but we forgot about the memory! Honest mistake, can happen to the best of us
4. again we have to repeat the clean-up code... what if we add more stuff later? We have to remember to add it here - in the graveyard

Some people (myself included in the past) try to be old-school smart and do this:

[source]
-------------------------------------------------------------------------------
       if (!num_read) {
              goto cleanup;
       }

       do_more_work(data_ptr);

cleanup:
       delete[] data_ptr;
       fclose(file_handle);
}
-------------------------------------------------------------------------------

Don't be like that!

Instead let the language work for you and don't be afraid to introduce intermediary elements that simplify the problem. Enter RAII (Resource Acquisition Is Initialisation) This basically means taking advantage of how object are destroyed at end of scope to create self-cleaning code:

[source]
-------------------------------------------------------------------------------
struct SmartFile {
       FILE *handle = nullptr;
       SmartFile(...) {
              handle = open_file(...);
       }
       ~SmartFile() {
              if (handle) {
                     fclose(handle);
              }
       }
};

void do_work()
{
       SmartFile file_handle{ ... };

       int size = calculate_file_length(file_handle);
       std::unique_ptr<char[]> data_ptr = std::make_unique<char[]>(size);

       int num_read = fread(data_ptr.get(), sizeof(char), size, file_handle);
       if (!num_read) {
              return;
              // the destructors of file_handle and data_ptr
              // will be automatically called
              // thus cleaning up properly
       }

       do_more_work(data_ptr);

       // no need to do anything
       // compiler got our back!
}
-------------------------------------------------------------------------------

Way better! Even if calculate_file_length throws, we still clean up the file handle. We used an unique smart pointer here, one that doesn't transfer ownership, if that is desired one can use std::shared_ptr or equivalents from your working codebase.

This technique is used throughout the Standard Library: the smart pointers mentioned above, `std::lock_guard`, `std::unique_lock`, `std::shared_lock` to manage mutexes etc.

Unreal Engine 4 uses it as well: `FScopeLock`, `FScopeCycleCounter`, `FScopedEvent` etc.

So we can leverage further unique_ptr and get rid of the custom class like so:

[source]
-------------------------------------------------------------------------------
       auto file_closer = [](FILE* f) {
              fclose(f);
       };

       std::unique_ptr<FILE, decltype(file_closer)> file = { 
              open_file(...), file_closer 
       };
-------------------------------------------------------------------------------   

Following along this idea, people devised a sort of automatic cleaner mechanism, with the most well-known being `Scope Exit` or `Scope Guard` originally invented by Andrei Alexandrescu. Here's a good talk about it by the author: https://www.youtube.com/watch?v=WjTrfoiB0MQ

This is basically a macro that allows us to write custom, in-place lambda's that will do the clean-up when it's needed. Here it is in action:

[source]
-------------------------------------------------------------------------------
void do_work()
{
       FILE *file_handle = open_file(...);
       SCOPE_EXIT(fclose(file_handle));
       if (!file_handle) {
              return;
       }

       int size = calculate_file_length(file_handle);
       char *data_ptr = new char[size];
       SCOPE_EXIT(delete[] ptr)

       int num_read = fread(data_ptr, sizeof(char), size, file_handle);
       if (!num_read) {
              return; // the SCOPE_EXIT's kick in
       }

       do_more_work(data_ptr);

       // the SCOPE_EXIT's kick in
}
-------------------------------------------------------------------------------

This thing is actually quite easy to implement; for a nice 10 lines of code version see the one from The Witness/Braid guys. The more involved, "official" implementation is maintained by Facebook.

That's it for now!
Continue the discussion in our usual HipChat channels: #programming and #C++11/14/17

Valentin Galea
