include::style.inline.txt[]

=== Use emplace instead of push_back/insert

Usually when working with container classes (be it STL or UE4 or home-grown) we will need to insert (or push, or append - depending on the API vocabulary) new values into them. Let's pretend we have the following class and a container:

[source]
-------------------------------------------------------------------------------
struct Widget
{
	Widget(int, float, char);
	
	/* ... */
};

std::vector<Widget> v;
-------------------------------------------------------------------------------

Let's construct something and put it in:

[source]
Widget w{ 0, 3.14f, 'A' };
v.push_back(w);

Simple stuff to write but not so simple performance wise. What's going on inside that function? Well it probably takes the argument by (const) reference so that's good, but still a temporary `Widget` is created by copy construction from `w` and then put inside the container. That's a bit too much, especially if `Widget` is a large object. Most probably once we put something in the container we don't need it anymore, so this should be better:

[source]
v.push_back(std::move(w));

It is - provided the move constructor is defined or the class is simple enough that the compiler provides one. How about when we work with pure temporaries?

[source]
v.push_back(Widget{ 0, 3.14f, 'A' });

Normally that wouldn't help much, but it so happens that push_back is overloaded for _rvalue references_, and we have a move constructor so this is a match made in heaven! Still, continuing the marriage metaphor, it may not always work out - we will later see that move semantics cannot be relied upon 100%.

All this stuff when we just wanted an object added to the container. Fire and forget - who cares about all this extra copies, moves etc! What if we could just construct the object right there in the newly allocated space by the container? Thanks to modern C++ we can totally do that:

[source]
v.emplace_back(0, 3.14f, 'A');

Notice how we only put in the constructor arguments and nothing else? It's because this function forwards them to the actual constructor called by the container when it allocates internally the new object! 0 overhead achieved!

DON'T do this btw:

[source]
v.emplace_back(Widget{ 0, 3.14f, 'A' });

That will construct a temporary and pass it on down the line - so we are no better than in the previous examples.

All standard containers that had `push_back`/`push_front` methods now have `emplace_back`/`emplace_front` alternatives. Emplacement is a powerful technique and you should take advantage of it when you can. Just be mindful of its implication: you are constructing in-place - if your construction errors out, you are leaving the container in a bad state... With the `push_back` version a copy was in flight for most of the time, and if that exploded, you could recover more easy.

We only talked about the standard libray, for reference here's an equivalence chart for Unreal Engine 4:

[source]
-------------------------------------------------------------------------------
/* STL */                           /* UE4 */
std::vector<Widget> v;              TArray<Widget> v;
Widget w{ 0, 3.14f, 'A' };

v.push_back(w);                     v.Append(w);
v.push_back(std::move(w));          v.Append(MoveTemp(w));
v.emplace_back(0, 3.14f, 'A');      v.Emplace(0, 3.14f, 'A');
-------------------------------------------------------------------------------

=== Careful about generated move ops

Speaking about move operations... The move semantics of the new C++ have some nasty gotchas that you need to be aware of, if you want to leverage them successfully.

Recall the definitions of the move constructor and move assignment operator:

[source]
struct Widget
{
	Widget(Widget &&) { /* ... */ }
	Widget& operator=(Widget &&) { /* ... */ }
};

The definitions alone look quite bad, coming up with the actual implementation and the very exact places where you need to place `std::move`'s can be understandably daunting. Can the compiler be trusted to generate these for "common-sense" classes? It turns out that not so much...

The problem is that the compiler will not generate them if:

1. your class has a destructor!
2. you defined a copy constructor and/or assignment operator!

The thinking behind 1) is that if you went to the trouble to add a destructor, then your class manages some non-trivial resources and the compiler cannot trust itself to generate moves for you - even if there was a straightforward way, or the destructor is trivial (for ex it just logs).

The real kicker is that under the same circumstance it will generate the copy constructor / assignment operator! This was considered for changing in C++11 but they reasoned that it will break too much legacy code - so for now it's just depecrated behaviour.

There is still hope! You can force the compiler's hand by `default`'ing the functions. If it really cannot generate them at least you will get a compiler error, instead of silence and surprise later on.

[source]
-------------------------------------------------------------------------------
struct Widget
{
	~Widget(); // normally this will hide move ops

	// force generate them
	Widget(Widget &&) = default;
	Widget& operator=(Widget &&) = default;
};
-------------------------------------------------------------------------------

Better yet: when possible don't write anything! Use the http://en.cppreference.com/w/cpp/language/rule_of_three[Rule of 0].

Until next time, +
Valentin Galea
