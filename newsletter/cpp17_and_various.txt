Hi all,

let's kick things off for this edition with some big news:

=== C++17 is final

The International Organization for Standardization (ISO) C\++ committee has announced the C++17 standard is complete. All that remains now is that our beloved Visual Studio implements it! In fairness they are off to a great start: the new 2017 edition is out and it implements quite a number of new features, with more coming in the future updates. Grab the latest (Update 1) https://www.visualstudio.com/vs/cplusplus/[here].

Let's quickly over over some of the new stuff - the more interesting things for game dev:

==== `if` statement with initializer

It is possible now to have initializers in 'if' and 'switch' statements!

[source]
if (init; condition)
switch (init; condition)

This should make easier a technique that people working with UE4 code surely have came across - and they either hated it or loved it:

[source]
if (auto world = GetWorld()) ...

At first this looks like a typo, but is actually legitimate and contains an implicit boolean check. We can make that check more explicit:

[source]
if (auto world = GetWorld(); world != nullptr) ...

Of course this is useful for more involved cases, and it also makes sure the new declared variable is properly scoped:

[source]
if (auto cam = CameraManager->ViewTarget.Target; cam->HasActorBegunPlay())
	// ... variable exist here
else
	// ... and only here
	
==== Structured bindings

This is basically syntactic sugar that should make returning multiple values from functions more attractive and easier. In a nutshell:

[source]
tuple<T1, T2, T3> func(/*...*/) { /*...*/ return { a, b, c }; }
auto [x, y, z] = func(); // x has type T1, y has type T2, z has type T3

In case you don't use tuple, it works for regular structures as well:

[source]
-------------------------------------------------------------------------------
struct mystruct { 
	int i; 
	string s;
	double d;
};
auto func() { return { 1, "xyzzy"s, 3.14 }; }

auto [x, y, z] = func(); // types are: int, string, double
-------------------------------------------------------------------------------

It also works with arrays:

[source]
int array[] = { 5, 7, 8, 9 };
auto [x, y, z, w] = array;

One thing to note is that these new auto variables are always references!

==== Lots of libray additions

We get:

* Filesystem - portable interaction with directories and files (listing directory contents, moving files, etc.)
* Parallelism - a lot of the std:: algorithms can take an extra argument that can specify multithreaded execution policy
* `string_view` - working with strings and char pointers but not owning them. Very useful for when you mainly you pass along and reference strings
* `optional` and `variant` - we talked about these in a previous newsletter
* `any` - a generalization of variant, you can now store `std::vector` of multiple item types
* new memory resources and a polymorphic allocator - this will only be of interest to Core-Tech
* `std::byte` - finally, right?

Courotines and modules didn't make it in, but they are available as previews in Visual Studio 2015 and 2017 for anyone who is interested.

Let's switch gears and cover some general topics that I came across during day to day work in the last month or so.

=== Implementing arithmetic and relational operators

Most often than not, there comes the need to have user define operators. These can be aritmethic, relational (for ex. equality tests for custom objects), array access, pointer manipulation, boolean etc.

There are two kinds of operators: unary (like `=`, `&`, `+=` etc) and binary (like in `==`, `+`, `/`) etc. The diffence is down to how many inputs they take when evaluating an expression.

We will concentrate only on the binary ones. These can be implemented both as member functions of their underlying type:

[source]
-------------------------------------------------------------------------------
struct Point
{
	float x, y;
	
	// method 1
	Point operator+(const Point &rhs);
	
	// method 2
	friend Point operator+(const Point &lhs, const Point &rhs);
};
-------------------------------------------------------------------------------

or as free functions:

[source]
struct Point
{
	float x, y;	
};

// method 3
Point operator+(const Point &lhs, const Point &rhs);

TODO:
* explain the difference - symetry
* explain friend and why it matters
* gotchas like short circuit
* why the lhs non const?
* how arithmetic is based on += etc and relational on == and <

=== Singletons

You should try hard to avoid using the singleton (anti)pattern. If you really must do - this is the best way to achieve it:

[source]
Singleton& instance()
{
	static Singleton s;
	return s;
}

This was first shown by Scott Meyers and since C++11 it's thread-safe by default. Don't mess around with global variables, pointers and such - you will open the door to a lot of gotchas.

Until next time,
Valentin