C++11/14 for gamedev
====================
practical new features

NOTE: TODO: bigger font

Purpose
-------
A survey of the new features of C++ 11 and 14 suitable for game development.

[role="incremental"]
It is presented for enumeration rather than guidance/style unless there is a clear proven benefit.

[role="incremental"]
Devs are encouraged to cherry pick features (maybe all!) and use them in day to day development to get faster, better and more maintainable code.

Support in compilers
--------------------
[options="header"]
|========================================================
| Compiler           | C++11                | C++14
| Visual Studio 2012 | partial (but usable) | none
| Visual Studio 2013 | almost full          | none
| Visual Studio 2015 | [red-background]#full# | almost full
|========================================================

TIP: More info: https://msdn.microsoft.com/en-us/library/hh567368.aspx http://en.cppreference.com/w/cpp/compiler_support

NOTE: TODO: colour the cells

<New language features>
---------------------

uniform initialisation
----------------------
C\+\+03 had a lot of inconsistencies with initialisation. C++11 fixes this by introducing a new idiom:

[role="incremental"]
[source,cpp]
widget W;           // works in all versions, declares uninitialised variable

[role="incremental"]
[source,cpp]
widget W();         // most-vexing-parse: you would think it's variable declaration but it's actually a function declaration
widget W{};         // C++11 new way of declaration - calls default constructor

[role="incremental"]
[source,cpp]
widget W(x);        // C++03 init by calling copy/convert constructor (depending on type of x)
widget W{x};        // C++11 same thing but safer

[role="incremental"]
[source,cpp]
widget W = x;       // still init (not assignment), calls copy constructor
widget W = {x};     // same thing but better - can potentially call move constructor

uniform initialisation (continued)
----------------------------------
Note: Doesn't do automatic narrowing conversion!

[role="incremental"]
[source,cpp]
int i = 1.0;        // compiles, implicitly converts from float to int
int i = { 1.0 };    // won't compile

[role="incremental"]
More examples:

[role="incremental"]
[source,cpp]
-------------------------------------------------------------------------------
int arr[]            { 1,2,3,4,5 };
std::vector<int> v   { 1,2,3,4,5 };
std::set<int> s      { 1,2,3,4,5 };

std::map<int,std::string> m { {0,"zero"}, {1,"one"}, {2,"two"} };

struct mystruct { int x, y; };
mystruct m = { 1, 2 };
-------------------------------------------------------------------------------

move semantics - lvalues/rvalues
--------------------------------
Every C++ statement is either an _lvalue_ or an _rvalue_.

[role="incremental"]
_lvalues_ generally sit on the left of =, are always named, persist and you can take their address.

[role="incremental"]
_rvalues_ generally sit on right of =, are temporary i.e. they don't persist beyond the expression that uses them.

[role="incremental"]
In C++03 you cannot do much with _rvalues_, you need to "capture" them by assignment if you want to use them otherwise they go away.

// https://msdn.microsoft.com/en-us/library/f90831hc.aspx
// http://blog.smartbear.com/development/c11-tutorial-explaining-the-ever-elusive-lvalues-and-rvalues/

move semantics - lvalue/rvalue - examples
-----------------------------------------
[role="incremental"]
[source,cpp]
/*lvalue*/ /*rvalue*/
int x      = 3 + 4;
*ptr;      // lvalue
&x;        // rvalue: the address of x
"hello";   // rvalue: literal

[role="incremental"]
[source,cpp]
int& func();
int func2();
func();     // lvalue, the call will return a meaningful address
func2();    // rvalue - an 'invisible' temporary is returned

[role="incremental"]
[source,cpp]
std::string("hello");   // rvalue
new int;                // rvalue
const widget y {};      // lvalue
int i;                  // lvalue
((i < 3) ? i : x) = 7;  // correct statement: the conditional operator returns lvalue

move semantics - rvalue references
----------------------------------
C++11 introduces _rvalue_ references: `<identifier> &&`

[role="incremental"]
They are most useful as arguments to functions in order to work with temporaries as well rather than "final result". Also now functions can return _rvalue_ references to optimise the passing around of the return value.
To leverage this, _move constructors_ and _move assignment operator_ are introduced.

[role="incremental"]
NOTE: In the context of template deduction && means something different: a "universal reference" used to implement perfect forwarding: that is ability to accept both _lvalue_ and _rvalue_ arguments.
[role="incremental"]
[source,cpp]
template<class T> void func(T&& arg); // not a rvalue reference, but could be!

move semantics - example
------------------------
[source,cpp]
-------------------------------------------------------------------------------
struct MemoryPage {
    void * address;
    size_t size;
    
    // appropriate constructor & destructor
    MemoryPage() {...}
    ~MemoryPage() {...}
    
    // copy constructor and assignment operator
    MemoryPage(const MemoryPage& other) {
        memcpy(address, other.address, other.size);
        size = other.size;
    }
    MemoryPage& operator=(const MemoryPage&) {
        // same expensive memcpy...
    }
-------------------------------------------------------------------------------

move semantics - example (continued)
-----------------------------------
[source,cpp]
-------------------------------------------------------------------------------
    // move constructor and move assignment operator
    MemoryPage(MemoryPage&& other) {
        // trivial swap of data
        address = other.address;
        size = other.size;
        // reset other, making it valid but empty
        other.address = nullptr;
        other.size = 0;
    }
    MemoryPage& MemoryPage::operator=(MemoryPage&& other) {
        // release the current object's resources
        delete[] address;
        size = 0;
        // swap from other and empty it just like in the copy constructor
        // ...
    }
}
-------------------------------------------------------------------------------

move semantics - usage (continued)
----------------------------------
[role="incremental"]
[source,cpp]
std::vector<MemoryPage> pages;
pages.push_back(MemoryPage());                  // avoid copy, insert directly
pages.push_back(MemoryPage());                  // again
pages.emplace_back((void *)0xFF02320, 1024);    // even better: C++11 method that does perfect forwarding and just constructs in-place (no move)

[role="incremental"]
_lvalues_ don't trigger move semantics, but they can be forced to with `std::move` (which is a fancy static_cast to &&)

[role="incremental"]
NOTE: within functions, arguments are always _lvalues_, even if originally at the call site a _rvalue_ was passed

[role="incremental"]
[source,cpp]
MemoryPage p(...);
pages.push_back(p);                // calls copy constructor
pages.push_back(std::move(p));     // calls move constructor, p is now useless on its own

[role="incremental"]
NOTE: UE4 version of std::move is called MoveTemp

auto
----
The type of the variable that is being declared will be automatically deduced from its initializer.

[role="incremental"]
[source,cpp]
 int j = 0;         // Variable j is explicitly type int.
auto k = 0;         // Variable k is implicitly type int because 0 is an integer.
auto d = 3.14;      // Variable d is double
auto f = 3.14f;     // Variable f is float

[role="incremental"]
[source,cpp]
map<int,list<string>>::iterator i = m.begin(); 
                           auto i = m.begin();
						   
[role="incremental"]
[source,cpp]
auto func = [](int arg) { return arg + 2; };
func();

auto (continued)
----------------
The rules of this deduction are the same of T from template declaration.

[role="incremental"]
This means that it doesn't deduct(it *drops*) `references` and `const` !!!

[role="incremental"]
[source,cpp]
-------------------------------------------------------------------------------
float& f1();
auto a1 = f1();     // a1 is value float, not reference!

const int f2();
auto a2 = f2();     // a2 is not const!

const Widget& f3();
auto Widget = f3(); // a3 is not reference, not const, it will be a copy!!!
-------------------------------------------------------------------------------

// Scott Meyer: https://www.youtube.com/watch?v=wQxj20X-tIU
// http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/

decltype
--------
Inspects the declared type of an entity or queries the type and value category of an expression.

[role="incremental"]
[source,cpp]
const int& foo();
const int bar();
int i;
struct A { double x; };
const A* a = new A();

[role="incremental"]
[source,cpp]
decltype(foo()) x1;    // type is const int &
decltype(bar()) x2;    // type is const int
decltype(i) x3;        // type is int
decltype(a->x) x4;     // type is double
decltype((a->x)) x5;   // type is const double & -- because of expression

decltype (continued)
--------------------
_decltype_ will get different results from _auto_ in similar situations:

[role="incremental"]
[source,cpp]
const int& x;
auto a1 = x;           // a1 is int
decltype(x) a2;        // a2 is const int &

[role="incremental"]
C++14 "fixes" this:

[role="incremental"]
[source,cpp]
decltype(auto) a2 = x; // a2 is const int &

constexpr
---------
Declares that it is possible to evaluate the value of the function or variable at compile time.

[role="incremental"]
Excellent replacement for macros: they are full C++ entities with scope and are debug-able!

[role="incremental"]
[source,cpp]
/* BAD */
#define MAGIC 0xFF04

[role="incremental"]
[source,cpp]
/* GOOD */
constexpr int MAGIC = 0xFF04;

[role="incremental"]
[source,cpp]
/* BAD */
#define FUNC(a, b) ((a) + (b) - 123)

[role="incremental"]
[source,cpp]
/* GOOD */
constexpr int FUNC(int a, int b)
{
        return a + b - 123;
}
// NOTE: can be template

constexpr (continued)
---------------------
constexpr functions in C++11 are limited in what they can use/do:

* only one return statement (but supports recursion)
* no if/while/for/switch
* no local variables.

C++14 relaxes these requirements a lot - but sadly VS 2015 doesn't support it

// https://www.youtube.com/watch?v=fZjYCQ8dzTc

range-based for loop
--------------------
[source,cpp]
int array[] = {0, 1, 2, 3, 4, 5};
std::vector<int> vector = {0, 1, 2, 3, 4, 5};

[role="incremental"]
[source,cpp]
for(int n: array)
    std::cout << n << ' ';

[role="incremental"]
[source,cpp]	
for(const int &i : vector) // access by const reference
    std::cout << i << ' ';

[role="incremental"]
[source,cpp]	
for(auto i: vector) // access by value, the type of i is int
    std::cout << i << ' ';

[role="incremental"]
TIP: works on anything that has .begin() and .end() or the free functions equivalent

alternative function declaration
--------------------------------
[source,cpp]
auto SomeFunction(int x, int y) -> int
{
    return x + y;
}

[role="incremental"]
_auto_ here means something different than in type deduction. C++14 allows the return type to be automatically deduced, no more need for `->`

[role="incremental"]
Especially needed in template declarations where the return type cannot be easily determined due to how the C++ parser works:

[role="incremental"]
[source,cpp]
/* ILLEGAL */
template<class L, class R>
Ret adding_func(const L &lhs, const R &rhs) { return lhs + rhs; } // what type is Ret???

[role="incremental"]
[source,cpp]
/* OK */
template<class L, class R>
auto adding_func(const L &lhs, const R &rhs) -> decltype(lhs + rhs) { return lhs + rhs; }

<Object construction improvements>
--------------------------------

=default
--------
Better explicit control over the treatment of default constructors and assignment operators. Leaving it to the compiler to implement the default behaviour is simpler, less error-prone, and often leads to better object code.

[source,cpp]
struct SomeType
{
    SomeType() = default; // the default constructor is explicitly stated, but it's not defined
    SomeType(OtherType value);
};

// https://en.wikipedia.org/wiki/C%2B%2B11#Explicitly_defaulted_and_deleted_special_member_functions
// https://isocpp.org/wiki/faq/cpp11-language-classes#default-delete

=delete
-------
Used to prohibit calling any function, which can be used to disallow construction, copying or undesired conversions.

[role="incremental"]
[source,cpp]
struct NonCopyable {
    NonCopyable() = default;
    NonCopyable(const NonCopyable&) = delete;
    NonCopyable& operator=(const NonCopyable&) = delete;
};

[role="incremental"]
[source,cpp]
struct OnlyDouble {
    void f(double d);
    template<class T> void f(T) = delete;
};

[role="incremental"]
This replaces the trick of moving the functions in the private section and doesn't generate any code.

delegating constructors
-----------------------
In C++03, if you want two constructors to do the same thing, repeat yourself or call "an init() function."

[role="incremental"]
Now constructors can call each other:

[role="incremental"]
[source,cpp]
class SomeType
{
    int number;
public:
    SomeType(int new_number) : number(new_number) {}
    SomeType() : SomeType(42) {}
};

// https://en.wikipedia.org/wiki/C%2B%2B11#Object_construction_improvement
// https://isocpp.org/wiki/faq/cpp11-language-classes#delegating-ctor

inheriting constructors
-----------------------
Non-virtual methods are not automatically available in derived classes. They have to be brought into scope with `using::` and in C++03 constructors couldn't be.

[role="incremental"]
[source,cpp]
-------------------------------------------------------------------------------
struct Base {
    Base(int);
    void f(double);
};

struct Derived : public Base { 
    using Base::f;      // lift Base's f into Derived's scope -- works in C++03
    void f(char);       // provide a new f 
    void f(double);     // prefer this f to Base::f(double) 
    
    using Base::Base;   // lift Base constructors into Derived's scope -- new in C++11
    Derived(char);      // provide a new constructor 
    Derived(int);       // prefer this constructor to Base::Base(int) 
};
-------------------------------------------------------------------------------

// https://isocpp.org/wiki/faq/cpp11-language-classes#inherited-ctors

explicit overrides and final
----------------------------
[role="incremental"]
[source,cpp]
struct Base {
    virtual void f();
    virtual void g() const;
    virtual void h(char) final;
    void k();               // not virtual
};

[role="incremental"]
[source,cpp]
struct Derived : Base {
    void f() override;      // OK: overrides B::f()
    void g() override;      // error: wrong signature
    virtual void h(char);   // error: attempt to override final method
    void k() override;      // error: B::k() is not virtual
};

[role="incremental"]
both _final_ and _override_ are contextual keywords - they can be used in normal declarations (but it's discouraged)

member initialisation
---------------------
[source,cpp]
struct S {
    int x = 7;
    int y {8};
    int &ref = x;
    S() : x(77) {} // override
};

[role="incremental"]
* If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored
* Doesn't work with bit fields
* References to temporaries are not allowed

<Lambda's>
----------

lambda
------
Anonymous in-place function (or alternatively an object called _closure_.

NOTE: TODO: images

lambda - C++14 additions
------------------------
[role="incremental"]
Generic arguments: (this effectively turns it into a template function)

[role="incremental"]
[source,cpp]
auto y = [] (auto first, auto second)
{
    return first + second;
};

[role="incremental"]
Capture expressions:

[role="incremental"]
[source,cpp]
auto y = [&ref = x, new_val = val + 1, x = std::move(x)]()
{
    // ...
};

[role="incremental"]
TIP: This especially allows capture by move, which wasn't possible before

lambda - gotchas
----------------
[role="incremental"]
* Beware of dangling references!

[role="incremental"]
[source,cpp]
{
	Widget w = ...
	callback = [&w]() { w.function(); }
}
callback(); // Disaster!

[role="incremental"]
* Beware of implicit capture of `this`

[role="incremental"]
[source,cpp]
struct Widget {
	int member;
	auto factory() {
		return [=]() { return member; }; // actually: this->member 
	}
}

[role="incremental"]
* Globals aren't captured - they are used like in normal functions

lambda - what's the type
------------------------
[role="incremental"]
* raw function pointer -- if it doesn't capture

[role="incremental"]
[source,cpp]
void (*func)(int, float) = [](int arg1, float arg2){};

[role="incremental"]
* hidden, unique "ClosureType" that can be only captured with _auto_

[role="incremental"]
[source,cpp]
auto func = [](int arg1, float arg2){};

[role="incremental"]
* `std::function` with the signature of the lambda argument types. Useful to pass around but heavyweight (uses type erasure which does heap alloc!) 

[role="incremental"]
[source,cpp]
std::function<int, float> func = [](int arg1, float arg2){};

