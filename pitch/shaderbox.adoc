= C++ In Disguise On The GPU For Fun And Profit 

The seeds of this talk were planted some time ago, during my long daily commute, while trying my hand at raytracing graphic shaders on mobile phones. OpenGL programming was actually getting in the way of rapid prototyping due to various driver bugs... C\++ to the rescue! Turns out that the C-like GPU shader languages of GLSL or HLSL can be compiled as modern C++ if one is willing to put in a bit of a library writing effort. All you mostly need is equivalent 2D/3D/4D vector and matrix types.

What's the catch then? Swizzling! The shader vector allows addressing of its components both as [0], [1], [2] etc but also as .x, .y, .xyz, .zyx, .xxx and all possible combinations. The talk details how this can be achieved in modern C++, clean and in a generic way, without preprocessor tricks, and overcome language obstacles like template argument deduction with implicit conversions.

Here is where C++ shows its strength - after all this effort it's possible to prototype complex procedural effects at an interactive rate with full CPU-side debugging. Of course, a dedicated GPU will very quickly outpace this but loses the debugging, and as mentioned some devices might not even produce 100% correct results.

As takeaway and showcase of what can be achieved with the C++ techniques presented I'll introduce Signed Distance Field functions modeling and some shaders that use it: Procedural Generated Planet, Volumetric Clouds simulation and some fun experiments: a Vinyl Turntable and an Egg On Bicycle!
