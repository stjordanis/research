= Rapid Prototyping of Graphics Shaders in Modern C++ 

Traditionally it's been hard or downright impossible to have C++ on a GPU: Graphics Shaders are mainly done in GLSL/HLSL (C-like languages) and Compute Shaders only recently run it via CUDA/LLVM complex toolchains. This is not always desirable or available - mobile phones for ex. Turns out code can compile both as valid C++ and shader language with a bit of library writing effort. All you mostly need is equivalent 2D/3D/4D vector and matrix types.

What's the catch then? Swizzling! The shader vector allows addressing of its components both as [0], [1], [2] etc but also as .x, .y, .xyz, .zyx, .xxx and all possible combinations. The talk details how this can be achieved in modern C++, clean and in a generic way, without preprocessor tricks, and overcome language obstacles like template argument deduction with implicit conversions.

Here is where C++ shows its strength - after all this effort it's possible to prototype complex procedural effects at an interactive rate with full CPU-side debugging. Of course, a dedicated GPU will very quickly outpace this but loses the debugging, and some devices might not even produce 100% correct results due to driver bugs.

As takeaway and showcase of what can be achieved with the C++ techniques presented I'll introduce Signed Distance Field functions modeling and some shaders that use it: Procedural Generated Planet, Volumetric Clouds simulation and some fun experiments: a Vinyl Turntable and an Egg On Bicycle!
