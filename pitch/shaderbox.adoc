- Embracing Limitations: C++ As GPU Shading Languages
- C++ In Disguise On The GPU For Fun And Profit 
- C++ In Disguise as GPU Shading Languages
- C++ In Disguise on the GPU: Rapid Prototyping of Graphics Shaders

The seeds of this talk were planted quite a while ago, on my long daily commute, with no seat to stand on, and GCC on my Android phone! All I wanted to do is write some raytracing graphics shaders, but OpenGL programming can make the forest disappear in the trees one too many times. C\++ to the rescue! Turns out that the C-like GPU shader languages of GLSL or HLSL can be compiled as modern C++ if one is willing to put in a bit of a library writing effort! All you mostly need are equivalent 2D/3D/4D vector and matrix types.

What's the catch then? Swizzling! The shader vector allows addressing of its components both as [0], [1], [2] etc but also as .x, .y, .xyz, .zyx, .xxx and all possible combinations. The talk details how this can be achieved in modern C++, clean and in a generic way, without preprocessor tricks, and overcome language obstacles like template argument deduction with implicit conversions.

Once again C++ shows its strength - after all this effort it's possible to prototype complex procedural effects at an interactive rate with full CPU-side debugging. Of course a dedicated GPU will very quickly outpace this but loses the debugging, and on some systems might not even produce 100% correct results due to driver bugs.

As takeaway and showcase of what can be achieved with the C++ techniques presented I'll introduce Signed Distance Field functions modeling and some shaders that use it: Procedural Generated Planet, Volumetric Clouds simulation and some fun experiments: a Vinyl Turntable and an Egg On Bicycle!