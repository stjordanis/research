#### C++11

##### What are *closures*?  What are *lambdas*?

Lambda = anonymous local function

Closure = lambda + reference to the environment (a table storing a reference to each of the non-local captured variables)

##### What is a *move assignment* operator?  When to use it?

Tied to the concept of rvalue-reference (or xvalue)

The move assignment operator is called whenever it is selected by overload resolution, e.g. when an object appears on the left side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.

Move assignment operators typically "steal" the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, move-assigning from a std::string or from a std::vector leaves the right-hand side argument empty.

More http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#Move_Semantics

##### What are the *atomic types* and how would you use them?

It allows lockless concurrent programming.

Each atomic operation is indivisible with regards to any other atomic operation that involves the same object. Atomic objects are the only C++ objects free of data races; that is, if one thread writes to an atomic while another thread reads from it, the behavior is well-defined.
